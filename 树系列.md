# 1367.二叉树中的列表

思考：（ListInTree.java）

```
思路一：
1.从根节点开始递归
2.判断树的当前节点是否与链表中当前节点相同
	2.1.若相同，则递归到下一层，并重复步骤2直到链表当前节点为null
	2.2.若不同，链表当前节点重置为head+(repeat-1,repeat表示相同的个数),重复步骤2直到当前节点为null

思路二：
1.递归树获得所有路径
2.判断路径中是否存在子路径与给定链表相同

```

题解：

```
1.找到树中链表开始节点
注意：在树中第一个链表节点后，子树还为第一节点，考虑这种情况
2.从链表第一节点开始递归查找，最终结果只有俩种情况
(1).链表遍历完，代表有子序列
(2).链表没遍历完，树遍历完，无子序列

```

# 102二叉树的层序遍历

LevelSort.java

```
思路：
从根节点开始进行递归，递归过程中记录当前节点的层数，再将值放入List<List<Integer>>的对应层数中。

题解:(BFS模板)
宽度优先搜索BFS:不需要确定当前遍历到了哪一层
while queue 不空：
    cur = queue.pop()
    for 节点 in cur的所有相邻节点：
        if 该节点有效且未访问过：
            queue.push(该节点)

宽度优先搜索BFS:需要确定当前遍历到了哪一层
level = 0
while queue 不空：
    size = queue.size()
    while (size --) {
        cur = queue.pop()
        for 节点 in cur的所有相邻节点：
            if 该节点有效且未被访问过：
                queue.push(该节点)
    }
    level ++;

```

# 685 冗余连接II

```
思路:
面临的问题：
有向图，树(没有指定是二叉树)
使用BFS?
总体思路与冗余连接类似，不过分两种情况

题解思路一:
若所有结点入度均为1，说明存在环路，直接建立并查集就可
若有一个结点入度为2，则有两个结点指向该结点，这两条边优先删除位于临边数组后边的一条边，若不能连通返回另一条，否则返回该条

题解思路二:
大致思路就是,根据题中问题:可能出现两种情况，一种就是环的存在,另一种就是重复父节点的问题（一个节点有两个父节点）
分步解决:
先合并有向边,找出可能存在的重复父节点问题
然后再重新初始化，解决是否存在环的问题


```

```java
//并查集：并查集由一个整形数组和两个函数构成，数组pre[]记录了每个点的前导点是什么,函数find查找,join是合并
int pre[1000];
int find(int x){  									//查找根节点
    int r=x;
    while ( pre[r] != r ){                           //返回根节点 r
          r=pre[r];
    }
    int i=x;  
    int j;
    while( i != r )                                   //路径压缩
    {
         j = pre[ i ]; 				// 在改变上级之前用临时变量  j 记录下他的值 
         pre[ i ]= r ; 				//把上级改为根节点
         i=j;
    }
    return r ;
}
//路径压缩，从任意节点到根节点的路径中遇到的节点，将他们的父节点全部改为根节点，从而提高find的效率。


//判断x y是否连通，如果已经连通，就不用管了 如果不连通，就把它们所在的连通分支合并起,
void join(int x,int y) {      
    int fx=find(x);
    int fy=find(y);
    if(fx!=fy)
        pre[fx ]=fy;
	}
}
```

https://blog.csdn.net/yjw123456/article/details/78929640

```
并查集:就是有‘合并集合’和‘查询集合中的元素’两种操作的关于数据结构的一种算法。
	连接两个对象,
	判断这两个对象是否相连
	
quick-find:



以什么条件作为是否根节点的界定？根据节点索引逐步构建pre[]数组
1.获取当前节点所有相连的节点
2.排除以当前节点为父节点的节点
3.若排除后不存在节点，则当前节点以自身为父节点，即为根节点
4.若排除后存在多个节点，则任选一个节点作为当前节点的父节点，其他节点为当前节点的子节点
```

# 173.二叉搜索树迭代器

```
思路：
中序遍历二叉搜索树，将所有的树节点构建成一个有序链表
```

# 124.二叉树中的最大路径和

```
最大路径和：根据当前节点的角色，路径可分为两种情况
一.以当前节点为根节点
1.只有当前节点
2.当前节点+左子树
3.当前节点+右子树
4.当前节点+左子树+右子树
这四种情况的最大值即为以当前节点为根的最大路径和,此最大值要和已经保存的最大值比较，得到整个树的最大路径值

二.当前节点作为父节点的一个子节点，和父节点连接的话，则需要取【单端的最大值】
1.只有当前节点
2.当前节点+左子树
3.当前节点+右子树
这三种情况的最大值

def maxValue(self,root):
        if root == None:            
            return 0
        
        leftValue = self.maxValue(root.left)
        rightValue = self.maxValue(root.right)
        
        value1 = root.val
        value2 = root.val + leftValue
        value3 = root.val + rightValue
        value4 = root.val + rightValue + leftValue
        
        #以此节点为根节点的最大值
        maxValue = max([value1,value2,value3,value4])
        
        #当前遍历树的最大值
        self.result = max(maxValue, self.result)
        
        #要和父节点关联，则需要取去除情况4的最大值
        return max([value1,value2,value3])


```

# 437.路径总和III

```
思路:
a+b+c = sum 可以变形为a = sum - b -c
递归树节点
判断给定值是否等于当前节点的值
	等于:遍历下一层节点
```

# 951.翻转等价二叉树

```
思路
  如果二叉树 root1，root2 根节点值相等，那么只需要检查他们的孩子是不是相等就可以了。
  存在三种情况：
  如果 root1 或者 root2 是 null，那么只有在他们都为 null 的情况下这两个二叉树才等价。
  如果 root1，root2 的值不相等，那这两个二叉树的一定不等价。
  如果以上条件都不满足，也就是当 root1 和 root2 的值相等的情况下，需要继续判断 root1 的孩子节点是不是跟 root2 的孩子节点相当。因为可以做翻转操作，所以这里有两种情况需要去判断。
  
自上而下，该翻转时就翻转，用递归的思维去解决问题

```

# 590.N叉树的后序遍历
 ```
思路：和二叉树的后序遍历并无太大不同
遍历所有的节点，最后遍历根
