# 1139.最大的以 1 为边界的正方形
给你一个由若干 0 和 1 组成的二维网格 grid，请你找出边界全部由 1 组成的最大 正方形子网格，
并返回该子网格中的元素数量。如果不存在，则返回 0。
思考：

```$xslt
令dp[i][j][0]表示点i,j左边连续1的最大个数
令dp[i][j][1]表示点i,j上边连续1的最大个数
即以点(i,j)为右下点的正方形

获得这部分数据后，再查询最大的正方形时，就不需要每个节点都判断min(i,j)次了
只需要判断min(dp[i][j][0],dp[i][j][1])次了,这也就是基于区间的dp问题
```
在动态规划中，寻找子问题可以通过区间，计数，树形的方向考虑，
合理的设置dp数组的意义，能够有效的解决问题。

# 740.删除和增加点数
```
首先明确一个概念,就是每个位置上的数字是可以在两种结果之上进行选择的
    将原数组进行排序并去重，例如(2,2,3,3,3,4) -> (0,0,2,3,1)，转换后的数组是all数组
all数组的下标就是原数组的值value,all数组的值value是原数组某个值出现的次数
    1.如果你不删除当前位置all[i]的数字，那么你得到就是前一个数字all[i-1]的位置的最优结果。
    2.如果你觉得当前的位置数字i需要被删，那么你就会得到all[i-2]位置的那个最优结果加上
当前位置的数字乘以个数。

dp公式:max{dp[i-1],dp[i-2]+all[i]*i}

将原来的数组转换为all数组之后，删除(i-1)和(i+1)的节点就变成了同一个数组上current和pre之间的关系
这就使得问题变得简单了

一维dp数组
如何提炼最优子结构？尝试将原结构稍微变化一下，或许问题就变得简单了?
```